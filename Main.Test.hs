-- Prereq: Install doctest if needed
-- Usage: Run
--   doctest Main.Test

module Main.Test where

import Grammar
import Main

-- | Unit tests the semantics of the conditional expression.
--
--   >>> ifExpr (B True) (I 5) (I 3) []
--   I 5
--
--   >>> ifExpr (B False) (I 5) (I 3) []
--   I 3
--
--   >>> ifExpr (B True) (S "abc") (I 123) []
--   S "abc"
--
--   >>> ifExpr (B False) (S "123") (B True) []
--   B True
--
--   >>> ifExpr (I 1) (S "123") (I 123) []
--   Error "Cannot branch expressions based on non-boolean condition"
--
--   >>> ifExpr (I 0) (S "123") (I 123) []
--   Error "Cannot branch expressions based on non-boolean condition"

-- | Unit tests the semantics of the string concatenation expression.
--
--   >>> strConcat (S "foo") (S "bar")
--   S "foobar"
--
--   >>> strConcat (S "123") (S "456")
--   S "123456"
--
--   >>> strConcat (S "foo") (I 3)
--   Error "Cannot concatenate non-strings"
--
--   >>> strConcat (B False) (S "foo")
--   Error "Cannot concatenate non-strings"
--
--   >>> strConcat (I 3) (B True)
--   Error "Cannot concatenate non-strings"

-- | Unit tests the semantics of arithmetic expression.
--
--   >>> arithExpr Add (I 5) (I 3)
--   I 8
--
--   >>> arithExpr Sub (I 3) (I 5)
--   I (-2)
--
--   >>> arithExpr Mul (I 4) (I 5)
--   I 20
--
--   >>> arithExpr Div (I 4) (I 5)
--   I 0
--
--   >>> arithExpr Div (I 10) (I 2)
--   I 5
--
--   >>> arithExpr Div (I 17) (I 3)
--   I 5
--
--   >>> arithExpr Add (S "123") (S "456")
--   Error "Cannot perform arithmetic operation on non-integers"
--
--   >>> arithExpr Sub (I 123) (S "456")
--   Error "Cannot perform arithmetic operation on non-integers"
--
--   >>> arithExpr Mul (B True) (S "456")
--   Error "Cannot perform arithmetic operation on non-integers"
--
--   >>> arithExpr Div (S "10") (S "2")
--   Error "Cannot perform arithmetic operation on non-integers"
--
--   >>> arithExpr Div (I 3) (I 0)
--   Error "Cannot perform division by zero"
--
--   >>> arithExpr Div (I 0) (I 0)
--   Error "Cannot perform division by zero"

-- | Unit tests the semantics of the unary boolean expression.
--
--   >>> boolExprUn Not (B True)
--   B False
--
--   >>> boolExprUn Not (B False)
--   B True
--
--   >>> boolExprUn Not (I 5)
--   Error "Cannot perform unary boolean operation on non-booleans"
--
--   >>> boolExprUn Not (S "True")
--   Error "Cannot perform unary boolean operation on non-booleans"

-- | Unit tests the semantics of binary boolean expressions.
--
--   >>> boolExprBi Eq (I 5) (I 5)
--   B True
--
--   >>> boolExprBi Eq (S "foo") (S "foo")
--   B True
--
--   >>> boolExprBi Gt (I 3) (I 2)
--   B True
--
--   >>> boolExprBi Lt (I 45) (I 43)
--   B False
--
--   >>> boolExprBi Gte (I 45) (I 43)
--   B True
--
--   >>> boolExprBi Lte (I 5) (I 5)
--   B True
--
--   >>> boolExprBi Lt (S "abc") (S "def")
--   Error "Cannot perform inequality boolean operations on strings"
--
--   >>> boolExprBi Eq (I 123) (S "123")
--   Error "Cannot perform binary boolean operation on non-strings or non-integers or mismatched types"

-- | Unit tests for bindings
--
--  >>> refExpr (N "a") [(N "a", I 3)]
--  I 3
--
--  >>> refExpr (I 3) [(N "a", I 3)]
--  Error "Must put name to refer a binded variable"
--
--  >>> expr (Ref (N "a")) []
--  Error "Value of 'a' not found"
--
--  >>> expr (Let [(N "a", I 2), (I 3, I 5), (N "b", B True)] (I 4)) []
--  Error "The binding list is not valid"
--
--  >>> expr (Let [] (I 2)) []
--  Error "Cannot bind an empty list"
--
-- | Integration tests for functions, bindings, along with other features
--
--  >>> expr (Let [((N "a"), I 3)] (Ref (N "a"))) []
--  I 3
--
--  >>> expr (Let [((N "a"), I 3)] ( Let [((N "a"), I 4)] (Ref (N "a")) )) []
--  I 4
--
--  >>> expr (Let [((N "a"), (If (B True) (I 3) (I 4)) )] (Ref (N "a"))) []
--  I 3
--
--  >>> expr (Let [((N "a"), (ArithExpr Add (I 1) (I 2)))] (Ref (N "a"))) []
--  I 3
--
-- | Integration tests for functions
--
--  >>> expr (Func (N "ais3") [(N "a")] (BoolExprBi Eq (Ref (N "a")) (I 3)) (Ref (N "ais3"))) []
--  C [] [N "a"] (BoolExprBi Eq (Ref (N "a")) (I 3))
--
--  >>> expr (Func (I 3) [(N "a")] (BoolExprBi Eq (Ref (N "a")) (I 3)) (Ref (N "ais3"))) []
--  Error "Function's name must be a string"
--
--  >>> expr (Func (N "ais3") [(N "a"), (I 2)] (BoolExprBi Eq (Ref (N "a")) (I 3)) (Ref (N "ais3"))) []
--  Error "Function parameters must be a list of strings"
--
--  >>> expr (Func (N "ais3") [(N "a")] (BoolExprBi Eq (Ref (N "a")) (I 3)) (Call (I 4) [I 3])) []
--  Error "Function's name must be a string"
--
--  >>> expr (Func (N "ais3") [(N "a")] (BoolExprBi Eq (Ref (N "a")) (I 3)) (Call (N "ais3") [I 3])) []
--  B True
--
--  >>> expr (Func (N "ais3") [] (I 2) (Call (N "ais3") [I 3])) []
--  Error "Number of arguments does not match number of parameter"
--
--  >>> expr (Func (N "ais3") [] (I 2) (Call (N "ais4") [])) []
--  Error "Function ais4 not found"
--
-- | Integration test for Static Scoping
--
--  let x = 3
--  define addToX (a) { x + a }
--  let x = 4
--  let y = addToX (5)
--  -> y = 8
--
--  >>> :{
--  expr (
--  Let [((N "x"), I 3)]
--  (Func (N "addToX") [(N "a")]
--      (ArithExpr Add (Ref (N "x")) (Ref (N "a"))) (
--  Let [((N "x"), I 4),
--       ((N "y"), Call (N "addToX") [I 5])]
--  (Ref (N "y"))
--  ))) []
--  :}
--  I 8
--
--  (Static scoping expect 8, dynamic binding expect 9
--  See: https://web.engr.oregonstate.edu/~walkiner/teaching/cs381-wi20/slides/5.ScopeAndParameters.pdf)
--
-- | Integration tests for recursion
--
-- Simple recursion
-- (define (fac n)
--      if (= n 1)
--          (1)
--          (* (n) (fac (- n 1))))
-- (fac 2)
--
--  >>> :{
-- expr(
-- Func (N "fac") [(N "n")]
-- (If (BoolExprBi Eq (Ref (N "n")) (I 1))
--      (I 1)
--      (ArithExpr Mul (Ref (N "n")) ( Call (N "fac") [ArithExpr Sub (Ref (N "n")) (I 1)] )))
-- (Call (N "fac") [I 2])
-- ) []
--  :}
--I 2
--
--
-- Fibbonaci
-- (define (fib n)
--     (if (= n 0) 0
--       (if (= n 1) 1
--         (+ (fib (- n 1)) (fib (- n 2))))))
--
-- (fib 2)
--
--  >>> :{
-- expr (
-- Func (N "fib") [(N "n")]
-- (If (BoolExprBi Eq (Ref (N "n")) (I 0))
--      (I 0)
--      (If (BoolExprBi Eq (Ref (N "n")) (I 1))
--          (I 1)
--          (ArithExpr Add
--              (Call (N "fib") [(ArithExpr Sub (Ref (N "n")) (I 1))])
--              (Call (N "fib") [(ArithExpr Sub (Ref (N "n")) (I 2))])
--          )
--      )
--  )
-- (Call (N "fib") [I 2])
-- ) []
--  :}
--I 1
